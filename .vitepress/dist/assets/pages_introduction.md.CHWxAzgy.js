import{_ as a,c as t,o as i,ae as n}from"./chunks/framework.BKvpiaTG.js";const d=JSON.parse('{"title":"What is sitelen Kuwi?","description":"","frontmatter":{},"headers":[],"relativePath":"pages/introduction.md","filePath":"pages/introduction.md"}'),s={name:"pages/introduction.md"};function r(o,e,l,h,u,c){return i(),t("div",null,e[0]||(e[0]=[n('<h1 id="what-is-sitelen-kuwi" tabindex="-1">What is sitelen Kuwi? <a class="header-anchor" href="#what-is-sitelen-kuwi" aria-label="Permalink to &quot;What is sitelen Kuwi?&quot;">​</a></h1><p><strong>sitelen Kuwi</strong>, also referred to by some as sitelen leko, is a script for <strong>toki pona</strong>. I originally designed this script for a separate project that was similar to toki pona, but after putting the project on hiatus, I decided to repurpose the script.</p><h2 id="why-not-just-use-sitelen-pona" tabindex="-1">Why not just use sitelen pona? <a class="header-anchor" href="#why-not-just-use-sitelen-pona" aria-label="Permalink to &quot;Why not just use sitelen pona?&quot;">​</a></h2><p>Unfortunately, I’ve never been a huge fan of sitelen pona, both aesthetically and functionally. This isn&#39;t to say sitelen pona is ugly or doesn&#39;t function well, but aesthetically, I personally have other preferences, and functionally, sitelen pona has its own issues that I personally wanted to address, which i will go into shortly.</p><h2 id="what-were-my-goals-when-creating-this-script" tabindex="-1">What were my goals when creating this script? <a class="header-anchor" href="#what-were-my-goals-when-creating-this-script" aria-label="Permalink to &quot;What were my goals when creating this script?&quot;">​</a></h2><p>I have always been somewhat dissatisfied with sitelen pona, and in my many years of attempts to discover what was behind that sentiment and what I actually wanted out of a toki pona script, I tried to develop various other ways to write toki pona. Eventually, I found myself returning to two issues time and time again: <strong>ambiguity</strong> and <strong>readability</strong>. but what does this mean?</p><h3 id="ambiguity" tabindex="-1">Ambiguity <a class="header-anchor" href="#ambiguity" aria-label="Permalink to &quot;Ambiguity&quot;">​</a></h3><p>toki pona is naturally an ambiguous language, which is <strong>completely fine</strong>. I have no problem with this in general, but what if there was a way to eliminate <em>some</em> ambiguity without changing the way the language functions at all? What if, when reading and writing (which are the main ways through which users consume material for toki pona), there were intuitive visual clues that could reduce some of this ambiguity? For example, what if we could more easily see if a word is acting as a preposition or noun and more easily show the relationship between different words? This is a question I toyed with in many different ways in my many different attempts to create a new writing system.</p><h3 id="readability" tabindex="-1">Readability <a class="header-anchor" href="#readability" aria-label="Permalink to &quot;Readability&quot;">​</a></h3><p>I consider toki pona to have three major categories for the syntactic role a word can play:</p><ul><li>particles,</li><li>content words, and</li><li>(what I call) function words.</li></ul><p>What does this have to do with legibility? Well, let’s take a detour to Japanese and try to understand where I’m coming from. For those of you who unfamiliar with how the language works, Japanese combines three separate writing systems, each with their own function for written communication. The writing systems are as follows:</p><ul><li><strong>Kanji</strong> are characters borrowed from Chinese which carry semantic meaning. <ul><li>For example, 魚 is the character for fish. This character represents a meaning, but not necessarily a pronunciation.</li></ul></li><li><strong>Hiragana</strong> is script native to Japan (although derived from cursive Kanji) that represents the language phonetically. <ul><li>For example, the characters <ruby>ひ<rt>hi</rt>ら<rt>ra</rt>が<rt>ga</rt>な<rt>na</rt></ruby> each represent one syllable, and when put together, they make up the word &quot;hiragana&quot;.</li></ul></li><li><strong>Katakana</strong> is similar in function to Hiragana but different in use. It is mainly used for more recent loan words (as compared to Kanji).</li></ul><p>Along with just the functional differences, there are also clear visual differences: Kanji tend to be more complex with many straight and angled lines while Hiragana tend to be curvier and more simple in comparison. Here is an example with Kanji in <span class="red">red</span> and Hiragana in <span class="blue">blue</span>:</p><blockquote><p><span class="red">私</span><span class="blue">は</span><span class="red">食堂</span><span class="blue">で</span><span class="red">食</span><span class="blue">べます</span>。</p></blockquote><p>Hopefully, it is clear from this example how these visual cues can quickly tell the reader where semantic meaning ends and grammar begins, which is exactly what I wanted to have as well. I wanted visual cues that could quickly tell the reader what part of toki pona’s grammatical patterns they are looking at.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>sitelen Kuwi is a project I undertook to create a script that is much easier to parse grammatically, such that readers can easily pick up on the functions and relationships of different words through orthography alone. Of course, this does not take away from my other objective of creating something I personally find aesthetically pleasing and fun to play with.</p>',18)]))}const m=a(s,[["render",r]]);export{d as __pageData,m as default};
